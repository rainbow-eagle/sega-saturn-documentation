# SEGA SGL Libraries, Conversion and Toolchain Compatibility

*Author: Anthony Cavallo*

## Document Purpose and Structure

This document provides a technical examination of the Sega Graphics Library (SGL) for the Sega Saturn, focusing on the binary formats of its library files, their incompatibility with modern sh-elf toolchains, and the engineering challenges encountered during conversion. It covers both library files (.A, .O) and header files (.h). It is intended for developers working with Saturn homebrew using GCC-based toolchains.

This document does not explain how to use SGL or what features it implements.
Understanding this document is not needed to use the SGL library.

The document is structured as follows:
1. SGL Library Files
	* 1.1. SGL Library File Format (.A archives)
	* 1.2. Root Causes of Incompatibility with sh-elf
	* 1.3. Detailed Archive Structure and Parsing Logic
	* 1.4. Special Case: SGLAREA.O – The SLPROG Section and Symbol Type Preservation
	* 1.5. Conversion Process and Implementation
2. Header File (.h) Encoding and Compatibility Issues  
	* 2.1. Windows Legacy Issues
	* 2.2. Case Inconsistency in #include Directives
	* 2.3. Japanese Character Loss and Recovery
	* 2.4. Conversion implementation 

---

## 1. SGL Library Files

### 1.1 SGL Library File Format (.A archives and .O objects)

SGL libraries are distributed as .A files (e.g. LIBCD.A, SEGA_SYS.A) and a few .O files (e.g. SGLAREA.O). The .A files are not standard GNU ar archives despite using the !<arch>\n signature. They are COFF-based object archives generated by Hitachi's SH development tools, not GNU binutils.

Key characteristics:
- Format: Sega-specific COFF ar variant
- Object type: Hitachi SH COFF (big-endian)
- Archive tool: Hitachi ar (not GNU ar)
- Member objects: Individual .o files in COFF format
- Symbol table: Extended long-name table prefixed with "/ "

These files appear to be ar archives but deviate significantly from BSD/GNU ar specifications.

---

### 1.2 Root Causes of Incompatibility with sh-elf

The sh-elf toolchain (GNU binutils for SuperH) fails to process SGL .A files due to:

1. Non-standard ar format: sh-elf-ar recognizes the archive but cannot extract members.
2. COFF format mismatch: sh-elf-objcopy expects GNU COFF, not Hitachi COFF.
3. Symbol table misinterpretation: The long-name table is parsed as filenames by ar tv.
4. Byte alignment and padding: Sega archives use strict even-byte alignment with occasional \n padding.
5. No standard member headers after the name table: Direct transition to COFF object data.
6. Some .O objects (both within .A archives and standalone) have a unique structure with a SLPROG section.

Result: when trying to convert from COFF to ELF, sh-elf-ar tv lists entries, but sh-elf-ar x produces no output.

---

### 1.3 Detailed Archive Structure

SGL .A files follow this layout:

```text
Offset (bytes)| Content
----------    |------------------------------------------------
0             | !<arch>\n (8 bytes)
8             | First header (60 bytes)
              |   Name: "/               " (indicates long name table)
              |   Size: e.g., "9050    " (name table size in decimal, right-aligned)
68            | Name table data ($L bytes)
              |   Contains null-terminated symbol names (e.g., _CDC_GetCurStat\0)
68+$L         | First member header (60 bytes)
              |   Name: e.g., "CDC_CMN.O       "
              |   Size: e.g., "2376    "
68+$L+60      | First member COFF object, e.g. CDC_CMN.O ($N bytes)
68+$L+60+$N   | Second member header (60 bytes)
68+$L+60+$N+60| Second member object ($M bytes)
...           | Subsequent header + object pairs
```


Critical observations:
- All sizes are stored as decimal ASCII, right-aligned in 10-byte fields.
- After each member, offset is padded to even byte if necessary.
- Rare off-by-one \n bytes appear between headers (handled by checking first byte).

---

### 1.4 Special Case: the SLPROG Section and Symbol Type Preservation

Some of the object files shipped with SGL require special handling during COFF-to-ELF conversion. Indeed, unlike most standalone`.O` file or member extracted from the `.A` archives, some contain a non-standard section named `SLPROG`. This section holds what are effectively global variables (e.g. `_CLOfstBuf`, `_MasterStack`, `_WorkBuf`, etc.), but in the original Hitachi COFF object they are intentionally marked as code symbols (type `T` in text section) rather than data symbols (`D` or `B`).

This design choice originates from the official Sega/SNK linker scripts, which explicitly place the `SLPROG` section in the executable code area via the directive `*(SLPROG)` in the `SLPROG` output section. By doing so, the official toolchain forces the linker to treat these symbols as having text type, even though semantically they are read/write data used by the library initialization code.

A naive conversion with `sh-elf-objcopy -I coff-sh -O elf32-sh` maps the `SLPROG` section to `.data` or `.bss` and consequently demotes all symbols to type `D` (global data) or `g` (global in small section).

To preserve the original behavior (symbols appear as `T` and reside in a code section), the conversion must explicitly inform binutils that `SLPROG` is an allocatable code section:

```bash
sh-elf-objcopy -I coff-sh -O elf32-sh \
    --set-section-flags SLPROG=alloc,code \
    SGLAREA.O SGLAREA_converted.O
```

Alternatively, the section can be renamed to `.text` while keeping the code flag, but preserving the original name and using the flag approach is cleaner and matches the intent of the official Sega linker scripts.

---

### 1.5 Conversion Process and Implementation

Our conversion method bypasses sh-elf-ar entirely and uses raw byte parsing. For each .A archive:

1. Read name table size from first header (offset 56–65, parsed as decimal).
2. Skip: 8 (magic) + 60 (header) + name_table_size.
3. Enter loop:
   a. Read 60-byte member header.
   b. If first byte is \n, skip one byte and re-read.
   c. Extract filename (bytes 0–15, trim / and trailing spaces).
   d. Extract size (bytes 48–57, parse decimal).
   e. Skip 60 bytes, extract size bytes → .coff file.
   f. Convert: sh-elf-objcopy -I coff-sh -O elf32-sh or special case if an SLPROG section is detected.
   g. Advance offset: +60 + size (+1 if odd).
4. After all members, use sh-elf-ar -rvs to create GNU-compatible .A.

This produces fully functional ELF archives usable with sh-elf-gcc.

Here is the full script that we used.

Please note that this script converts all standalone .O files although this does not make much sense. Indeed, only SGLAREA.O is worth converting as the other ones are only meant to be included in an IP.BIN file and not used for actual linking.

```bash
#!/bin/bash
set -x

# Converts Sega COFF libs (with long name table) in ELF libs


# location of sh-elf tools (objcopy and ar)
bindir=..
# directory where the elf lib will be created
destdir=lib_elf

# Converts libs by extracting .o, converting, and reassembling them.
convert_sega_coff() {
    local input="$1"      # e.g. LIBCD.A
    local output="$2"     # e.g. LIBCD_ELF.A
    local temp_dir=$(mktemp -d)

    echo "Converting $input → $output"

    # Read name table size
    local name_size_str=$(dd if="$input" bs=1 skip=56 count=10 2>/dev/null | tr -d ' \0')
    local size=$((10#$name_size_str))
    echo "  Name table size: $size bytes"

    # For whatever reason the file starts with 8 useless chars.
    local offset=8
    local merged_objs=()

    #Locate each .o file, extract and convert it to ELF
    while true; do
        # Next header (pad to even)
        local offset=$((offset + 60 + size))
        [ $((offset % 2)) -eq 1 ] && offset=$((offset + 1))

        # Read next header
        local header=$(dd if="$input" bs=1 skip=$offset count=60 2>/dev/null)
        [ ${#header} -lt 59 ] && break

        #There's a weird case where a header starts with "\n", off by one... 
        if [[ ${header:0:1} = $'\n' ]]; then
            local offset=$((offset + 1))
            local header=$(dd if="$input" bs=1 skip=$offset count=60 2>/dev/null)
            [ ${#header} -lt 59 ] && break
        fi

        local name=$(echo "$header" | cut -b1-16 | sed -r 's|(.*)/.*$|\1|')
        local size_str=$(echo "$header" | cut -b49-58 | sed 's/ *$//')
        local size=$((10#$size_str))

        # Skip if size 0 or invalid
        [ $size -le 0 ] && break

        # And of course extract the coff .o and convert it to elf.
        local obj_file="$temp_dir/${name%}"
        dd if="$input" bs=1 skip=$((offset + 60)) count=$size of="$obj_file.coff" 2>/dev/null
#        $bindir/sh-elf-objcopy -I coff-sh -O elf32-sh "$obj_file.coff" "$obj_file" 2>/dev/null || continue
        if $bindir/sh-elf-objdump -h "$obj_file.coff" 2>/dev/null | grep -q SLPROG; then
            echo "    → Contains SLPROG section → special conversion"
            $bindir/sh-elf-objcopy -I coff-sh -O elf32-sh \
                --set-section-flags SLPROG=alloc,code,contents \
                --set-section-alignment SLPROG=32 \
                "$obj_file.coff" "$obj_file"
        else
            $bindir/sh-elf-objcopy -I coff-sh -O elf32-sh "$obj_file.coff" "$obj_file"
        fi
        merged_objs+=("$obj_file")
    done

    # Link all the elf .o into one .A
    if [ ${#merged_objs[@]} -gt 0 ]; then
        $bindir/sh-elf-ar -rvs "$output" "${merged_objs[@]}" 
        echo "  Merged ${#merged_objs[@]} objects → $output"
    else
        echo "  No objects found!"
        rm -rf "$temp_dir"
        return 1
    fi

#    rm -rf "$temp_dir"
    echo "Done: $output"
}

mkdir $destdir
# Convert all lib files
for lib_file in *.A; do
    [ -f "$lib_file" ] || continue
    convert_sega_coff "$lib_file" "$destdir/$lib_file"
done
# Convert all the standalone .o files except SGLAREA.O which isn't standard
for obj_file in *.O; do
    [ -f "$obj_file" ] || continue
    # Special handling for SGLAREA.O — preserve SLPROG as code
    if [ -f "SGLAREA.O" ]; then
        echo "Special conversion for SGLAREA.O (preserving SLPROG as code)"
        $bindir/sh-elf-objcopy -I coff-sh -O elf32-sh \
            --set-section-flags SLPROG=alloc,code \
            SGLAREA.O "$destdir/SGLAREA.O"
        echo "Done: SGLAREA.O (symbols preserved as T)"
    else
        $bindir/sh-elf-objcopy -I coff-sh -O elf32-sh "$obj_file" "$destdir/$obj_file" 2>/dev/null
        echo "Done: $obj_file"
    fi
done
```

---

## 2. Header File (.h) Encoding and Compatibility Issues

SGL header files suffer from multiple encoding and formatting problems that prevent direct use with modern GCC toolchains. We explain the issues and provide a script to fix them all at the end of this Section.

### 2.1 Windows Legacy Issues
Files use CRLF line endings, CP1252/CP932 encoding, and contain stray control characters (e.g., 0x1A). These cause preprocessor warnings or syntax errors.  
Solution: Convert with `iconv -f CP932 -t UTF-8` and `dos2unix`, then strip 0x1A with `tr -d '\032'`.

### 2.2 Case Inconsistency in #include Directives
Original headers use mixed case in #include paths (e.g., #include "sega_cdc.h"), while library and object files are all uppercase (SEGA_CDC.H, CDC_CMN.O). This breaks case-sensitive filesystems and consistent builds.  
Fix: Manually normalize all #include targets to uppercase in SGL.H, SEGA_CDC.H, and SEGA_GFS.H.

### 2.3 Japanese Character Loss and Recovery
The primary issue is the **loss of Japanese documentation** in comments and strings due to incorrect encoding conversion.

Original headers (from Sega Japan) contain **Shift-JIS (CP932)** text, including:
- Function descriptions in Japanese
- Macro documentation
- File headers with author names and dates

When converted with `iconv -f CP1252`, Japanese characters become unreadable (e.g., Ã©Â instead of ライブラリ).  
Correct source encoding is **CP932 (Shift-JIS)**, not CP1252.

### 2.4 Conversion implementation

```bash
#!/bin/bash

mkdir -p ../inc_utf8
for f in *.H; do
    echo "Fixing $f..."
    iconv -f CP932 -t UTF-8 "$f" -o "../inc_utf8/$f"
done
cd ../inc_utf8
for f in *.H; do
    tr -d '\032' < "$f" > "$f.tmp" && mv "$f.tmp" "$f"
done
```
